[
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Resources and Acknowlegements",
    "section": "",
    "text": "All the labs listed here are from the E155 website\nLattice Semiconductors has a YouTube series explaining Radiant’s tools and workflow. This was immensly helpful during Lab 1"
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "Hello Quarto",
    "section": "",
    "text": "I want to (and am required by my instructor) to start off this blog by discussing my learning goals for this course. First, I’ll talk a bit about why I chose to take this course, then I’ll discuss what I’d like to get out of it. For context for anyone unrelated to Harvey Mudd College, E155 otherwise known as Micro Ps is one of the most feared in the engineering department. This is mostly due to the challenging work and hours and hours of lab-time required every week. However, anyone who’s taken it will also tell you that they learned more in this class than in any other they’ve taken. It follows the concepts of E85: Digital Electronics and Computer Engineering and was recommded for those who enjoyed that class. And, well, as of last semester when I took E85, it was one of the best I had taken so far. This came as no srprise since I’ve always been interested in electronics, especially digital electronics, so when it came time to choose my courses for this semester and microprocessors was offered as an upper-div elective, I decided to take it.\nI expect that this class will be the most demanding I have ever taken, requiring lots of time and expecting high-quality work. I’ve had to face the first challenge before, but I’ve yet to take a class that demands high-quality deliverables like that. I see this as an opportunity to dip my feet in to what it’s like to be a real engineer. In prior classes like E80 (a project-based systems/electronics/robotics course required for the major), the deliverables were important, but what was more important was our work and learning. In this class, I get the sense that our end-products are the most important–like in most real-world engineering jobs. I love to problem-solve and find creative solutions to difficult problems, but I sometimes have trouble seeing things through to the end and developing high-quality products. I’m excited to take our TA’s advice and enjoy this class by putting in the time. There’s so much I’m excited to explore, and I can’t wait to get into it."
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "Lab 1: FPGA and MCU Setup and Testing Introduction",
    "section": "",
    "text": "Time spent: 15 hours\nGitHub Repository\n\n\nThis week, I soldered the dev-board including through-hole and surface-mount technology. I also set up and learned to use the programs used to make this website (Quarto, GitHub) and interface with the FPGA and MCU (QuestaSim, Radiant, Segger, and more GitHub). Finally, I wrote a System Verilog module to control a 7-segment hexadecimal display, built the accompanying circuit, and uploaded it to the FPGA.\n\n\n\nI won’t go into much detail about the first few parts, since although they took the majority of my time this week, the process of soldering or learning to use tools is not particularly interesting. Instead, I will focus on the design of the final module.\nThe main goal was to make a program to make a seven-segment representation of a hex digit corresponding to 4 dip switches on the dev board. In addition, we were asked to make one of the onboard LEDs blink at 2.4Hz and two more change their states based on the switch positions.\nThe system verilog for this week was straightforward. First, I figured out how to blink the LED. The lab description suggested we use the configurable high-speed oscillator (HSOSC) on the FPGA. I set the frequency to 24MHz and then created a counter to reset at 10,000,000. Since 24MHz/10,000,000 = 2.4Hz, I made the LED change every time the counter resets.\nThe following is a block diagram of my intended design.\n\nThe truth tables given for the two other onboard LEDs could be represented as an XOR operator on the first two bits and an AND on the second two. This was easily accomplished with assign statements. Then, I used a case statement to encode the truth table for display outputs.\nOnce this was written, I chased errors mostly due to bad syntax before I imported the file to QuestaSim. Getting QuestaSim to work as expected was more difficult than expected, but after using Radiant’s simulation wizard to create a new QuestaSim project that included the source program and the libraries for the FPGA (which included the HSCOSC module). Since QuestaSim uses a different compiler than Radiant, there were some more syntax issues I needed to fix. After this was done, I used force commands as suggested to set the switch positions and observed the output in the wave view.\n\n\nI had some issues getting the s bus to change value even after force statements, but what I saw made enough sense that I decided to move on. Though I didn’t know it at the time, I had ordered the bits of the 7-segment display opposite of what I wanted, which you can see in the figures above.\nAfter a moderately successful simulation, I looked at the block diagram given by Radiant.\n\nAs you can see, despite the very large number required by the counter, the structure is fairly simple. I was also curious how the seg_driver was interpreted, so I found its schematic. I would expect this block to be some K-map simplified gate array, but instead, I saw this\n\nThis diagram was interesting, and I’d love to learn what Radiant thinks it’s doing here but I decided to move on and trust the process. Prof. Brake suggested that the long binary encodes some information like a lookup table would, but this is clearly not the hardware I implied.\nAt this point, I had already assembled the 7-segment display circuit. The displays we used have a common-cathode design, meaning the display is powered by one pin, and each segment can be toggled by setting its corresponding pin low so current can drain through the LED. I placed a current-limiting resistor at the anode of each segment. This uses more resistors than having on at the common cathode, but ensures the current through each segment does not depend on how many are lit in total. The lab description suggests 5-20mA. I found the value of the resistor with R = 5V/20mA = 250Ohms.\n\nWith the circuit assembled and the pins connected to the FPGA, all that was left was to assign pins (I kept track of the 7-segment display’s pins in a text document in the GitHub repo) and upload to the board. I did this but found that a few things still needed to be fixed.\n\n\n\nFirst Attempt\n\n\nOne segment was not lighting at all as shown in the figure above, and several of the digits were incorrect. I fixed the first issue by changing which pin the segment used. The second issue was caused by the reverse-ordered bits in the seg bus. Once I fixed this, the display was working correctly and met the requirements of the lab. All 16 digits are shown below for your viewing pleasure.\n\n\n\n0\n\n\n\n\n\n1\n\n\n\n\n\n2\n\n\n\n\n\n3\n\n\n\n\n\n4\n\n\n\n\n\n5\n\n\n\n\n\n6\n\n\n\n\n\n7\n\n\n\n\n\n8\n\n\n\n\n\n9\n\n\n\n\n\nA\n\n\n\n\n\nb\n\n\n\n\n\nc\n\n\n\n\n\nd\n\n\n\n\n\ne\n\n\n\n\n\nf"
  },
  {
    "objectID": "labs/lab1/lab1.html#lab-1-fpga-and-mcu-setup-and-testing-introduction",
    "href": "labs/lab1/lab1.html#lab-1-fpga-and-mcu-setup-and-testing-introduction",
    "title": "Lab 1: FPGA and MCU Setup and Testing Introduction",
    "section": "",
    "text": "Time spent: 15 hours\nGitHub Repository\n\n\nThis week, I soldered the dev-board including through-hole and surface-mount technology. I also set up and learned to use the programs used to make this website (Quarto, GitHub) and interface with the FPGA and MCU (QuestaSim, Radiant, Segger, and more GitHub). Finally, I wrote a System Verilog module to control a 7-segment hexadecimal display, built the accompanying circuit, and uploaded it to the FPGA.\n\n\n\nI won’t go into much detail about the first few parts, since although they took the majority of my time this week, the process of soldering or learning to use tools is not particularly interesting. Instead, I will focus on the design of the final module.\nThe main goal was to make a program to make a seven-segment representation of a hex digit corresponding to 4 dip switches on the dev board. In addition, we were asked to make one of the onboard LEDs blink at 2.4Hz and two more change their states based on the switch positions.\nThe system verilog for this week was straightforward. First, I figured out how to blink the LED. The lab description suggested we use the configurable high-speed oscillator (HSOSC) on the FPGA. I set the frequency to 24MHz and then created a counter to reset at 10,000,000. Since 24MHz/10,000,000 = 2.4Hz, I made the LED change every time the counter resets.\nThe following is a block diagram of my intended design.\n\nThe truth tables given for the two other onboard LEDs could be represented as an XOR operator on the first two bits and an AND on the second two. This was easily accomplished with assign statements. Then, I used a case statement to encode the truth table for display outputs.\nOnce this was written, I chased errors mostly due to bad syntax before I imported the file to QuestaSim. Getting QuestaSim to work as expected was more difficult than expected, but after using Radiant’s simulation wizard to create a new QuestaSim project that included the source program and the libraries for the FPGA (which included the HSCOSC module). Since QuestaSim uses a different compiler than Radiant, there were some more syntax issues I needed to fix. After this was done, I used force commands as suggested to set the switch positions and observed the output in the wave view.\n\n\nI had some issues getting the s bus to change value even after force statements, but what I saw made enough sense that I decided to move on. Though I didn’t know it at the time, I had ordered the bits of the 7-segment display opposite of what I wanted, which you can see in the figures above.\nAfter a moderately successful simulation, I looked at the block diagram given by Radiant.\n\nAs you can see, despite the very large number required by the counter, the structure is fairly simple. I was also curious how the seg_driver was interpreted, so I found its schematic. I would expect this block to be some K-map simplified gate array, but instead, I saw this\n\nThis diagram was interesting, and I’d love to learn what Radiant thinks it’s doing here but I decided to move on and trust the process. Prof. Brake suggested that the long binary encodes some information like a lookup table would, but this is clearly not the hardware I implied.\nAt this point, I had already assembled the 7-segment display circuit. The displays we used have a common-cathode design, meaning the display is powered by one pin, and each segment can be toggled by setting its corresponding pin low so current can drain through the LED. I placed a current-limiting resistor at the anode of each segment. This uses more resistors than having on at the common cathode, but ensures the current through each segment does not depend on how many are lit in total. The lab description suggests 5-20mA. I found the value of the resistor with R = 5V/20mA = 250Ohms.\n\nWith the circuit assembled and the pins connected to the FPGA, all that was left was to assign pins (I kept track of the 7-segment display’s pins in a text document in the GitHub repo) and upload to the board. I did this but found that a few things still needed to be fixed.\n\n\n\nFirst Attempt\n\n\nOne segment was not lighting at all as shown in the figure above, and several of the digits were incorrect. I fixed the first issue by changing which pin the segment used. The second issue was caused by the reverse-ordered bits in the seg bus. Once I fixed this, the display was working correctly and met the requirements of the lab. All 16 digits are shown below for your viewing pleasure.\n\n\n\n0\n\n\n\n\n\n1\n\n\n\n\n\n2\n\n\n\n\n\n3\n\n\n\n\n\n4\n\n\n\n\n\n5\n\n\n\n\n\n6\n\n\n\n\n\n7\n\n\n\n\n\n8\n\n\n\n\n\n9\n\n\n\n\n\nA\n\n\n\n\n\nb\n\n\n\n\n\nc\n\n\n\n\n\nd\n\n\n\n\n\ne\n\n\n\n\n\nf"
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Week 1 Reflection\n\n\n\n\n\nComplaining about Lab 1\n\n\n\n\n\nSep 7, 2024\n\n\nAvery Smith\n\n\n\n\n\n\n\n\n\n\n\n\nHello Quarto\n\n\n\n\n\nFirst Post - Learning Goals\n\n\n\n\n\nAug 27, 2024\n\n\nAvery Smith\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Avery Smith is third year engineering major at Harvey Mudd College. At HMC, he has worked in RESIST Lab under Prof. Dre Helmns working with control systems for HVAC applications. He is also active in the Pomona College Theatre Department with theatre as his HSA concentration. He also enjoys the outdoors and takes any chance to go on an adventure. He is taking e155 this semester and looks forward to building his understanding of digital design and communication."
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "Time spent: 12 Hours [GitHub Repository]"
  },
  {
    "objectID": "labs/lab2/lab2.html#lab-2-multiplexed-7-segment-display",
    "href": "labs/lab2/lab2.html#lab-2-multiplexed-7-segment-display",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "Time spent: 12 Hours [GitHub Repository]"
  },
  {
    "objectID": "labs/lab2/lab2.html#main-goals",
    "href": "labs/lab2/lab2.html#main-goals",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Main Goals",
    "text": "Main Goals\nThe point of this lab is to drive two seven-segment displays using one seven-segment encoder. This was to be achieved by generating a time-multiplexed display signal meaning the output of the encoder will switch rapidly between what display 1 and 2 should read, along with corresponding enable signals for each display. In general, multiplexing can decrease cost since a single piece of hardware can be used for many purposes. Additionally, the sum should be displayed on 5 LEDs."
  },
  {
    "objectID": "labs/lab2/lab2.html#summary",
    "href": "labs/lab2/lab2.html#summary",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Summary",
    "text": "Summary\nTo meet these goals, I designed the following layout.  The system takes in s1, and s2 (set by the onbaord and one external dip-switch) and outputs sum: the sum signal to send to the leds, seg: the 7-seg encoded signal for the display, and en1 and en2: enable signals to switch between active displays.\nI chose to switch active displays at F = 1.46kHz (12MHz/2^13) since this is well above the threshold for humans to percieve flickering, but slow enough that hardware issues are not a concnern. I decided to implement this with a clock divider since it was the simplest way to implement this functionality, but in more complicated sequential design requiring low-freuency flops, they should take in an enable signal.\nI wrote the top module and created the elements in a Radiant project and checked the netlist analyzer to make sure it matched my intended design. Sure enough it did, except for the segment encoder (again, but at this point it will be a running bit since it still works!)\nTop: \nAdder: \nTime Mux: \nSegment Encoder: \nI used QuestaSim to simulate the adder and time_mux modules. After some tweaking, the adder and time multiplexer worked as expected\nAdder:\nTime Multiplexer: \nSince I had already simulated the encoder last week, I skipped that and went right to simulating the top module. Some further fixing and tweaking, and it worked as expected (although I forgot to take a screenshot).\nA consideration for this lab, and any FPGA project is how to drive all the necessary hardware without exceeding the current limit of the FPGA pins. The suggested current limit is +/- 8mA. This value is not a strict limit, and as we saw last lab, the current into a pin can reach 15mA-20mA without issue. However, since the common-anode displays must be supplied with much more current than this, two 2N3906 PNP transistors were used to drive the enable signals for the displays. The base signals of the transistors were connected to the FPGA, so current will flow from collector to emmitter when the FPGA pins are pulled low. 510Ohm resistors were used to limit the 3.3V current through the base node to 5.2mA (I = 510/3.3). I used 470Ohm resistors for the LEDs to get 7.0mA and 150Ohm for the segment display to get 22mA, but since we did that last lab, I know it will work. The schamtic for each element is below.\n\nWith the circuit assembled and the logic designed, the FPGA was ready for programming. The system worked as expected for most inputs, but for certain combinations, the left segment display was flickering terribly, and the sum leds were inconsistent in their bit assignment. After poking around with Prof. Brake, we determined that the issue lied somehwere in the hardware. Some input pins seemed to have continuity with the output which was causing interference. The extent of the flickering could be changed by wiggling the connector from the dev board to the bread board, so that was likely the culprit.\nI’m coming back to this, but at this point, the stock room is locked, so I can’t try another ribbon cable. Next steps include asking prof. Brake for help, using the FPGA directly on the breadboard, or (though hopefully not), turning in what I have now."
  },
  {
    "objectID": "labs.html",
    "href": "labs.html",
    "title": "E155 Labs",
    "section": "",
    "text": "These are reflections and documentation from all the labs I will work on this semester. It is still a work-in-progress, but as I complete the labs, I will add info here!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLab 1: FPGA and MCU Setup and Testing Introduction\n\n\n\n\n\n\n\n\n\n\n\nSep 3, 2024\n\n\nAvery Smith\n\n\n\n\n\n\n\n\n\n\n\n\nLab 2: Multiplexed 7-Segment Display\n\n\n\n\n\n\n\n\n\n\n\nSep 10, 2024\n\n\nAvery Smith\n\n\n\n\n\n\n\n\n\n\n\n\nLab 3: Keypad Scanner\n\n\n\n\n\n\n\n\n\n\n\nAug 27, 2024\n\n\nAvery Smith\n\n\n\n\n\n\n\n\n\n\n\n\nLab 4: Digital Audio\n\n\n\n\n\n\n\n\n\n\n\nAug 27, 2024\n\n\nAvery Smith\n\n\n\n\n\n\n\n\n\n\n\n\nLab 5: Interrupts\n\n\n\n\n\n\n\n\n\n\n\nAug 27, 2024\n\n\nAvery Smith\n\n\n\n\n\n\n\n\n\n\n\n\nLab 6: The Internet of Things and Serial Peripheral Interface\n\n\n\n\n\n\n\n\n\n\n\nAug 27, 2024\n\n\nAvery Smith\n\n\n\n\n\n\n\n\n\n\n\n\nLab 7: The Advanced Encryption Standard\n\n\n\n\n\n\n\n\n\n\n\nAug 27, 2024\n\n\nAvery Smith\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/week1.html",
    "href": "posts/week1.html",
    "title": "Week 1 Reflection",
    "section": "",
    "text": "Week 1 of this course was deceptively difficult. The main purpose of the lab was to make a seven-segment display controller to represent hex 0-F based on the position of 4 onboard dip-switches. This design challenge was straightforward and mostly easy for me to figure out. However, since this was the first lab of the class, I had to download and setup all of the FPGA/MCU programming, interfacing, and simulation software while using GitHub for the first time in ernest. Between licensing issues, duplicate main/master branches, and MCU firmware issues, it’s not an exaggeration to say this was the most difficult first assignment I’ve ever had. That being said (and I had to write about it somehwere), after navigating this lab, I feel like I can take on anything this class has to throw at me. I’m excited to work with System Verilog (a phrase I never thought I would say) to make real-life designs."
  }
]