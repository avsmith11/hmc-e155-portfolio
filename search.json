[
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Resources and Acknowlegements",
    "section": "",
    "text": "All the labs listed here are from the E155 website\nLattice Semiconductors has a YouTube series explaining Radiant’s tools and workflow. This was immensly helpful during Lab 1"
  },
  {
    "objectID": "posts/week2.html",
    "href": "posts/week2.html",
    "title": "Week 2 Reflection",
    "section": "",
    "text": "My hope is that this week is as bad as this class gets for me. I started working on the lab too late and ended up with an error I didn’t know how to debug after the weekend office hours were over. This meant when I encountered a bug I didn’t know how to fix, I had to wait to find a time during the week (after my checkoff was due) to meet with Prof. Brake. Still, I learned that asking for help, even when it should have been done earlier, is a good idea.\nThe majority of work on the lab went smoothly. I felt myself becoming more comfortable with the FPGA workflow, and SystemVerilog was coming out of me more smoothly than it did last week. But, after I simulated everything and uploaded it to the FPGA, I got weird behavior I had no idea how to diagnose. At the time, it felt almost impossible that I could stick in an oscilloscope probe and fix the issue. While I was frustratedly debugging on Tuesday night, I accidentally knocked a voltage regulator off the back of the FPGA. Something I’ve learned in my two years of engineering experience is that if it’s late at night and things start to break, the best decision is almost always to call it a night and deal with it later.\nOn Thursday, I talked through my issue with Prof. Brake and realized that it must be due to a floating value somewhere. My classmate Troy (who had the same issue) suggested changing the internal pull-up on the input switches to 3.3kOhm instead of 100kOhm, and this fixed the problem. If I had gotten an earlier start, I would have been much less sad this week, but even with the sadness incurred due to this lab, it felt pretty awesome to see it finally working.\nMy takeaways are these: 1. I need to start earlier so I can take advantage of tutoring hours, and 2. When I run into an issue, I should talk about it so anyone with the same issue or other applicable experience can help."
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "Hello Quarto",
    "section": "",
    "text": "I want to (and am required by my instructor) to start off this blog by discussing my learning goals for this course. First, I’ll talk a bit about why I chose to take this course, then I’ll discuss what I’d like to get out of it. For context for anyone unrelated to Harvey Mudd College, E155 otherwise known as Micro Ps is one of the most feared in the engineering department. This is mostly due to the challenging work and hours and hours of lab-time required every week. However, anyone who’s taken it will also tell you that they learned more in this class than in any other they’ve taken. It follows the concepts of E85: Digital Electronics and Computer Engineering and was recommded for those who enjoyed that class. And, well, as of last semester when I took E85, it was one of the best I had taken so far. This came as no srprise since I’ve always been interested in electronics, especially digital electronics, so when it came time to choose my courses for this semester and microprocessors was offered as an upper-div elective, I decided to take it.\nI expect that this class will be the most demanding I have ever taken, requiring lots of time and expecting high-quality work. I’ve had to face the first challenge before, but I’ve yet to take a class that demands high-quality deliverables like that. I see this as an opportunity to dip my feet in to what it’s like to be a real engineer. In prior classes like E80 (a project-based systems/electronics/robotics course required for the major), the deliverables were important, but what was more important was our work and learning. In this class, I get the sense that our end-products are the most important–like in most real-world engineering jobs. I love to problem-solve and find creative solutions to difficult problems, but I sometimes have trouble seeing things through to the end and developing high-quality products. I’m excited to take our TA’s advice and enjoy this class by putting in the time. There’s so much I’m excited to explore, and I can’t wait to get into it."
  },
  {
    "objectID": "labs/lab3/lab3.html",
    "href": "labs/lab3/lab3.html",
    "title": "Lab 3: Keypad Scanner",
    "section": "",
    "text": "Time Spent: 13 hours\nGitHub Repository"
  },
  {
    "objectID": "labs/lab3/lab3.html#main-goals",
    "href": "labs/lab3/lab3.html#main-goals",
    "title": "Lab 3: Keypad Scanner",
    "section": "Main Goals",
    "text": "Main Goals\nThe challenge for this lab was to create scanning logic for an 8-pin 16-button hexadecimal pin pad. Then we had to integrate this with last week’s lab to display the most recent and previous button presses on a dual seven-segment display."
  },
  {
    "objectID": "labs/lab3/lab3.html#design",
    "href": "labs/lab3/lab3.html#design",
    "title": "Lab 3: Keypad Scanner",
    "section": "Design",
    "text": "Design\nThis design used four main modules: a scanner and decoder, a debouncer, a shift register, and a dual segment driver which contains the time mux and segment encoder from last week’s lab. The block diagram for the project is below.\n\nMy first challenge was to design scanning logic to read the pressed button. The keypad has four rows and four columns as shown in the diagram below courtesy of the e155 website.\n\nWhen the i, jth button is pressed, the pins corresponding to the ith column and jth row are connected. I decided I would apply voltage to the rows and measure the columns as inputs. However, voltage cannot be applied to all four rows at the same time since there would be no way to distinguish which row the jth column was connected to. Instead, suppose the FPGA scans one row at a time, applying voltage to each row in quick succession. In that case, the active row and column can be used to determine which button is pressed, and if the scanning rate is sufficiently fast, it is unnoticeable to the user. I designed the FSM below to handle this task.\n\nIn states S0-S3, the corresponding row (rx) is set high and the scanner looks for a button press (indicated by a column going high). If a button push is registered, the state is set to the holding states S4-S7. Otherwise, the pattern S0-&gt;S1-&gt;S2-&gt;S3 continues. Once the FSM is in one of the bottom states, it stays there until no buttons are pushed. I’m using a 5-bit output bus “button”. In the top four states, button is set to 10000 to indicate no button is pressed, and in the bottom four states, the row and column are decoded to the appropriate hexadecimal value and placed in the bottom four bits of button. the top bit is set low in S4-S7 to indicate a button is pressed. This whole FSM ran off an enable signal from a clock divider at ~11kHz - fast enough to be unnoticable by the user, but slow enough that there was no concern of RF effects or parasitic capacitance interfering with operation.\nThe next module I designed was the debouncer. This module handles two of the lab specifications: 1. If multiple buttons are pressed at the same time, only the first one should register 2. A button push should only be registered once In general, a debouncer is a piece of hardware or software the ignores the instability of a switch or button for a short period after it is pressed. This instability is called switch bounce. Since this can occur over a period of 1-5 ms, I decided to measure the bounce of my pin pad using the oscilloscopes in lab. After testing several times, I did not observe any bounce, but I still made the module since it is required for the lab. I designed it as another FSM pictured below. I chose a value on the small end of this scale since choosing a larger debouncing tolerance could result in a noticable input delay.\n\nThis module takes in the button signal set by the scanner and outputs a 4-bit debounced button signal along with a 1-bit pulse. It operates similarly to a step-to-pulse FSM, but includes a counting state before the pulse and holding states. The FSM stays in this state until a button has been pressed for more than 1.4 ms (arbitrary). Then the FSM gives sets deb_button to the bottom four bits of button, generates a 1-clock pulse, and moves to the holding state for as long as a button is held. If at any point button = 10000 indicating no button is pressed, the state is set to waiting.\nI implemented a shift register to store the most recent and previous button presses. The shift register updates when a pulse is received from the debouncer module. The display driver encodes the current and last value given by the shift register to a seven-segment signal and uses time-multiplexing to utilize both displays with one signal plus two enables. The display driver varies from the top module I made last week in two ways: 1. I removed the adder module 2. The clock is passed through as an input and is no longer generated within the module"
  },
  {
    "objectID": "labs/lab3/lab3.html#testing",
    "href": "labs/lab3/lab3.html#testing",
    "title": "Lab 3: Keypad Scanner",
    "section": "Testing",
    "text": "Testing\nTo test this project, I designed a test bench for each submodule, as well as one for the top module. None of the test benches were self-checking since it was easy enough to read off the outputs. I’ll explain here what I looked for.\nMy initial tests were full of bugs, but after tracking them all down, here’s what I saw.\n\n\n\nShift Register\n\n\nOn the pulses, the deb_button value is sent to current, and current is sent to last\n\n\n\nDebouncer\n\n\nWhen the button is pressed for more than 1.4ms, deb_button gets button[3:0] and pulse goes high for one clock cycle. If another button is pressed while in the holding state, the press is ignored. If the button is pressed for less than 1.4ms, there is no pulse and no change to deb_button.\n\n\n\nDual Segment Driver\n\n\nThough it’s too small to see in this screenshot, the output seg alternates between the inputs s1 with en1 low (enable signals are active low) and s2 with en2 low. This is all this module is supposed to do.\n\n\n\nScanner and Decoder\n\n\nWhen button = 0000, the rows are switching rapidly as expected, then when some bit of button goes high, the active row stays active and button gets 0xxxx where xxxx is the appropriate hexadecimal value for the active row and column. I had an issue in this module where the fsm would only stay in the bottom states for one clock cycle regardless of input, and by plotting the state signals, I was able to diagnose that there was an issue with my nextstate logic.\n\n\n\nTop\n\n\nIn the top module, we see the same row behavior for column inputs as above. Then, though it can’t be seen in this screenshot, the alternating values of seg match the current and last button presses and match up with the en1 and en2 signals.\nFor robustness, I should have tested inputs where several columns are high at the same time, but I was happy with these results, and it didn’t end up being a problem."
  },
  {
    "objectID": "labs/lab3/lab3.html#implementation",
    "href": "labs/lab3/lab3.html#implementation",
    "title": "Lab 3: Keypad Scanner",
    "section": "Implementation",
    "text": "Implementation\nThe only physical design the lab required was a circuit for the pin-pad. The rows are active-high outputs and the columns are inputs with pulldown resistors.\n\nI used the same circuit for the display as last week, but changed some of the pin connections\n\nI used Radiant to synthesize the design and upload it to the FPGA. The schematics generated by Radiant are shown below:\n\n\n\nTop\n\n\n\n\n\nScanner and Decoder\n\n\n\n\n\nDebouncer\n\n\n\n\n\nShift Register\n\n\n\n\n\nDisplay Driver\n\n\nWith the design synthesized, I uploaded it to the FPGA and it worked as demonstrated at the top of this page!"
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "Lab 1: FPGA and MCU Setup and Testing Introduction",
    "section": "",
    "text": "Time spent: 15 hours\nGitHub Repository\n\nMain Goals:\nThis week, I soldered the dev-board including through-hole and surface-mount technology. I also set up and learned to use the programs used to make this website (Quarto, GitHub) and interface with the FPGA and MCU (QuestaSim, Radiant, Segger, and more GitHub). Finally, I wrote a System Verilog module to control a 7-segment hexadecimal display, built the accompanying circuit, and uploaded it to the FPGA.\n\n\nSummary:\nI won’t go into much detail about the first few parts, since although they took the majority of my time this week, the process of soldering or learning to use tools is not particularly interesting. Instead, I will focus on the design of the final module.\nThe main goal was to make a program to make a seven-segment representation of a hex digit corresponding to 4 dip switches on the dev board. In addition, we were asked to make one of the onboard LEDs blink at 2.4Hz and two more change their states based on the switch positions.\nThe system verilog for this week was straightforward. First, I figured out how to blink the LED. The lab description suggested we use the configurable high-speed oscillator (HSOSC) on the FPGA. I set the frequency to 24MHz and then created a counter to reset at 10,000,000. Since 24MHz/10,000,000 = 2.4Hz, I made the LED change every time the counter resets.\nThe following is a block diagram of my intended design.\n\nThe truth tables given for the two other onboard LEDs could be represented as an XOR operator on the first two bits and an AND on the second two. This was easily accomplished with assign statements. Then, I used a case statement to encode the truth table for display outputs.\nOnce this was written, I chased errors mostly due to bad syntax before I imported the file to QuestaSim. Getting QuestaSim to work as expected was more difficult than expected, but after using Radiant’s simulation wizard to create a new QuestaSim project that included the source program and the libraries for the FPGA (which included the HSCOSC module). Since QuestaSim uses a different compiler than Radiant, there were some more syntax issues I needed to fix. After this was done, I used force commands as suggested to set the switch positions and observed the output in the wave view.\n\n\nI had some issues getting the s bus to change value even after force statements, but what I saw made enough sense that I decided to move on. Though I didn’t know it at the time, I had ordered the bits of the 7-segment display opposite of what I wanted, which you can see in the figures above.\nAfter a moderately successful simulation, I looked at the block diagram given by Radiant.\n\nAs you can see, despite the very large number required by the counter, the structure is fairly simple. I was also curious how the seg_driver was interpreted, so I found its schematic. I would expect this block to be some K-map simplified gate array, but instead, I saw this\n\nThis diagram was interesting, and I’d love to learn what Radiant thinks it’s doing here but I decided to move on and trust the process. Prof. Brake suggested that the long binary encodes some information like a lookup table would, but this is clearly not the hardware I implied.\nAt this point, I had already assembled the 7-segment display circuit. The displays we used have a common-cathode design, meaning the display is powered by one pin, and each segment can be toggled by setting its corresponding pin low so current can drain through the LED. I placed a current-limiting resistor at the anode of each segment. This uses more resistors than having on at the common cathode, but ensures the current through each segment does not depend on how many are lit in total. The lab description suggests 5-20mA. I used a 250Ohm resistor, so I = (3.3V - 0.7V)/250 Ohm = 10mA\n\nWith the circuit assembled and the pins connected to the FPGA, all that was left was to assign pins (I kept track of the 7-segment display’s pins in a text document in the GitHub repo) and upload to the board. I did this but found that a few things still needed to be fixed.\n\n\n\nFirst Attempt\n\n\nOne segment was not lighting at all as shown in the figure above, and several of the digits were incorrect. I fixed the first issue by changing which pin the segment used. The second issue was caused by the reverse-ordered bits in the seg bus. Once I fixed this, the display was working correctly and met the requirements of the lab. All 16 digits are shown below for your viewing pleasure.\n\n\n\n0\n\n\n\n\n\n1\n\n\n\n\n\n2\n\n\n\n\n\n3\n\n\n\n\n\n4\n\n\n\n\n\n5\n\n\n\n\n\n6\n\n\n\n\n\n7\n\n\n\n\n\n8\n\n\n\n\n\n9\n\n\n\n\n\nA\n\n\n\n\n\nb\n\n\n\n\n\nc\n\n\n\n\n\nd\n\n\n\n\n\ne\n\n\n\n\n\nf"
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Week 3 Reflection\n\n\n\n\n\nFinally getting it\n\n\n\n\n\nSep 17, 2024\n\n\nAvery Smith\n\n\n\n\n\n\n\n\n\n\n\n\nWeek 2 Reflection\n\n\n\n\n\nGetting help with pesky bugs\n\n\n\n\n\nSep 13, 2024\n\n\nAvery Smith\n\n\n\n\n\n\n\n\n\n\n\n\nWeek 1 Reflection\n\n\n\n\n\nComplaining about Lab 1\n\n\n\n\n\nSep 7, 2024\n\n\nAvery Smith\n\n\n\n\n\n\n\n\n\n\n\n\nHello Quarto\n\n\n\n\n\nFirst Post - Learning Goals\n\n\n\n\n\nAug 27, 2024\n\n\nAvery Smith\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Avery Smith is third year engineering major at Harvey Mudd College. At HMC, he has worked in RESIST Lab under Prof. Dre Helmns working with control systems for HVAC applications. He is also active in the Pomona College Theatre Department with theatre as his HSA concentration. He also enjoys the outdoors and takes any chance to go on an adventure. He is taking e155 this semester and looks forward to building his understanding of digital design and communication."
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "Time spent: 13 Hours\nGitHub Repository"
  },
  {
    "objectID": "labs/lab2/lab2.html#main-goals",
    "href": "labs/lab2/lab2.html#main-goals",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Main Goals",
    "text": "Main Goals\nThe point of this lab is to drive two seven-segment displays using one seven-segment encoder. This was to be achieved by generating a time-multiplexed display signal meaning the output of the encoder will switch rapidly between what display 1 and 2 should read, along with corresponding enable signals for each display. In general, multiplexing can decrease cost since a single piece of hardware can be used for many purposes. Additionally, the sum should be displayed on 5 LEDs."
  },
  {
    "objectID": "labs/lab2/lab2.html#summary",
    "href": "labs/lab2/lab2.html#summary",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Summary",
    "text": "Summary\nTo meet these goals, I designed the following layout.  The system takes in s1, and s2 (set by the onboard and one external dip-switch) and outputs sum: the sum signal to send to the LEDs, seg: the 7-seg encoded signal for the display, and en1 and en2: enable signals to switch between active displays.\nI chose to switch active displays at F = 1.46kHz (12MHz/2^13) since this is well above the threshold for humans to perceive flickering, but slow enough that hardware issues are not a concern. I decided to implement this with a clock divider since it was the simplest way to implement this functionality. Still, in more complicated sequential designs requiring low-frequency flops, they should take in an enable signal.\nI wrote the top module, created the elements in a Radiant project, and checked the netlist analyzer to ensure it matched my intended design. Sure enough, it did, except for the segment encoder (again, but at this point it will be a running bit since it still works!)\nTop: \nAdder: \nTime Mux: \nSegment Encoder: \nI used QuestaSim to simulate the adder and time_mux modules. After some tweaking, the adder and time multiplexer worked as expected.\nAdder:\nTime Multiplexer: \nSince I had already simulated the encoder last week, I skipped that and went right to simulate the top module. I did some further fixing and tweaking, and it worked as expected (although I forgot to take a screenshot).\nA consideration for this lab, and any FPGA project is how to drive all the necessary hardware without exceeding the current limit of the FPGA pins. The suggested current limit is +/- 8mA. This value is not a strict limit, and as we saw last lab, the current into a pin can reach 15mA-20mA without issue. However, since the common-anode displays must be supplied with much more current than this, two 2N3906 PNP transistors were used to drive the enable signals for the displays. The base signals of the transistors were connected to the FPGA, so current would flow from the collector to the emitter when the FPGA pins were pulled low. 510Ohm resistors were used to limit the 3.3V current through the base node to 5.2mA (I = 510/3.3). I used 470Ohm resistors for the LEDs to get 7.0mA and 150Ohm for the segment display to get 22mA, but since we did that last lab, I know it will work. The schematic for each element is below.\n\nWith the circuit assembled and the logic designed, the FPGA was ready for programming. The system worked as expected for most inputs, but for certain combinations, the left segment display was flickering terribly, and the sum LEDs were inconsistent in their bit assignment. After poking around with Prof. Brake, we determined that the issue lay somewhere in the hardware. After noticing that placing my finger under the breakout cable connections on the bottom of the dev board fixed the flickering issue, I hypothesized that there were floating values somewhere that were fixed by the dielectric of my finger. I changed the internal pull-up resistors to 3.3kOhm, and, like magic (but not really magic), it started working.\nBelow are some pictures of the display and sum working as intended:"
  },
  {
    "objectID": "labs/lab4/lab4.html",
    "href": "labs/lab4/lab4.html",
    "title": "Lab 4: Digital Audio",
    "section": "",
    "text": "Time Spent: 13 hours\nGitHub Repository"
  },
  {
    "objectID": "labs/lab4/lab4.html#main-goals",
    "href": "labs/lab4/lab4.html#main-goals",
    "title": "Lab 4: Digital Audio",
    "section": "Main Goals",
    "text": "Main Goals\nThis week, I was tasked to design and build a solution to play melodies from a speaker. The main hurdle was the low-level implementation of drivers for on-board peripherals."
  },
  {
    "objectID": "labs/lab4/lab4.html#design",
    "href": "labs/lab4/lab4.html#design",
    "title": "Lab 4: Digital Audio",
    "section": "Design",
    "text": "Design\nTo play melodies, you need a way to generate tone and a way to control the duration of this tone. The STM32L432KC MCU we’re using has several on-board peripherals including 11 timers. These timers are widely configurable and can operate at a wide range of frequencies (MHz - minutes). For this project, I chose to use the general-purpose timers 15 and 16—one to generate settable frequencies between 60 Hz and 1000 Hz and another to generate settable delays between 0.5 ms and 30s.\nThe block diagram below shows how the clock can be configured. The counter is the main part of the clock which ticks up every CK_CNT. The frequency of CK_CNT is equal to the internal clock (CK_INT) divided by the value in the prescaler (PSC prescaler). The auto-reload and capture/compare always check the values of the counter. When the counter reaches the value in the auto-reload register (ARR), the counter is reset and an update signal is generated. If the counter reaches the value in the capture/compare register (CCR), an update signal is generated (note, this will only happen if CCR &lt; ARR). The timers can be configured such that an output pin can be driven directly from a signal generated by the capture/compare register that goes high when CNT&gt;CCR. These clocks allow generation of a PWM signal with a duty cycle which can be set in software equal to (1-CCR)/ARR that is sent directly to an output pin.\n\nThe system clock into both of the timers was set to 4MHz. The prescaler, counter, auto-reload, and capture/compare are all 16-bit values (1 - 65,536).\n\nFrequency Timer\nThe frequency timer (TIM16) is required to produce frequencies down to 80Hz, but with a prescaler of 1 (CK_CNT = CK_INT = 4MHz), the auto-reload can be set to produce values between 60.03Hz and 4MHz.\nmin freq = 4MHz/1 = 4MHz || max freq = 4MHz/(2^16-1) = 60.03Hz, where freq = CK_CNT / ARR (counter is blocked when ARR = 0)\nIn software, the ARR is set to a calculated value to achieve the required frequency and CCR is set to ARR/2 to get a 50% waveform.\nSince F = CK_CNT / ARR, ARR = CK_CNT / F = 4MHz / F, where F is given by the song data.\nARR can only be an integer, so there is some error in the output frequency due to rounding. The difference between possible frequencies gets smaller as ARR increases. So, for higher frequencies, the error will be greater than for smaller frequencies. I calculated the maximum possible error for a given frequency around 1000Hz (the maximum required frequency for this lab) to ensure it is under the 1% tolerance required. The maximum possible error in frequency at ~1000Hz is half of the difference between achievable frequencies since a frequency between allowed frequencies will either be rounded up or down. Using the equation, we can find that ARR = 4000 for F = 1000 Hz. So I compared the frequencies from ARR = 4000 and 4001 to find the error. I also calculated the error at around 80Hz (ARR = 50000) out of curiosity.\nmax error @~1000Hz = 1/2 * (4MHz/4000 - 4MHz/4001) = 0.12Hz &lt; 1%*1000Hz\nmax error @~80Hz = 1/2 * (4MHz/50000 - 4MHz/50001) = 0.0008Hz &lt; 1%80Hz\nThese calculations confirm that the error is below 1% throughout the frequency range required by the lab.\n\n\nDelay Timer\nFor the delay timer, I decided to use CK_CNT = 0.5ms as the base unit, since that is mostly imperceptible and allows for delays up to 32.8s. The math for this was easier in the time domain, so I found the clock period TCK_INT = 1/4MHz = 2.5E-7s. To set TCK_CNT = 0.5ms, I set PSC = TCK_CNT/TCK_INT= 2000. Then, to set a specific delay, ARR = delay/TCK_CNT.\nWith this configuration, the maximum and minimum delays are as follows:\nTmax = TCNT_CLK*(2^16-1) = 32.7675s || Tmin = TCNT_CLK(1) = 0.5ms\n\n\nOther Considerations\nTo make the timers work, the system clock was configured to 4Mz and sent enabled for the required peripherals, and the output GPIO pin was set to take the output value directly from the frequency timer.\n\n\nmain function\nThe actual code for this project was relatively simple and is included below. I loop through the notes in the song of choice (in this case Fur Elise). The notes are pairs of frequencies and duration. The setPWM function configures the frequncy timer to the desired frequency, and the Delay function configures the delay timer and waits for the desired amount of time. The frequency goes directly to the speaker and the delay is used to time the loop through frequencies with the correct timing."
  },
  {
    "objectID": "labs/lab4/lab4.html#testing",
    "href": "labs/lab4/lab4.html#testing",
    "title": "Lab 4: Digital Audio",
    "section": "Testing",
    "text": "Testing\nI tested this design using the debug feature in Segger. The implementation was at the register level, so using the internal register map included in Segger, I could compare the register values to what I intended. Once I got rid of obvious bugs, I built the circuit and used an oscilloscope to find bugs with the output. The debugging process was made easier by checking with peers and grutors to identify issues with the registers since even with the reference manual, there are still gaps in my understanding of all the registers. I hope to work on this in the next lab, but by using these methods while stepping through my code in the debugger, I was able to make the lab work."
  },
  {
    "objectID": "labs/lab4/lab4.html#implementation",
    "href": "labs/lab4/lab4.html#implementation",
    "title": "Lab 4: Digital Audio",
    "section": "Implementation",
    "text": "Implementation\nThe physical implementation of this lab called for an LM386 auditio amplifier to provide higher voltage and current to the speaker than could be achieved. The datasheet included an example design that I slightly modified. The amplification is unimportant since the output is a square wave, so high/low is all I need. I also included a potentiometer on the output to control the speaker’s volume.\n![] (images/circuit.png)"
  },
  {
    "objectID": "labs.html",
    "href": "labs.html",
    "title": "E155 Labs",
    "section": "",
    "text": "These are reflections and documentation from all the labs I will work on this semester. It is still a work-in-progress, but as I complete the labs, I will add info here!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLab 1: FPGA and MCU Setup and Testing Introduction\n\n\n\n\n\n\n\n\n\n\n\nSep 3, 2024\n\n\nAvery Smith\n\n\n\n\n\n\n\n\n\n\n\n\nLab 2: Multiplexed 7-Segment Display\n\n\n\n\n\n\n\n\n\n\n\nSep 10, 2024\n\n\nAvery Smith\n\n\n\n\n\n\n\n\n\n\n\n\nLab 3: Keypad Scanner\n\n\n\n\n\n\n\n\n\n\n\nSep 16, 2024\n\n\nAvery Smith\n\n\n\n\n\n\n\n\n\n\n\n\nLab 4: Digital Audio\n\n\n\n\n\n\n\n\n\n\n\nOct 2, 2024\n\n\nAvery Smith\n\n\n\n\n\n\n\n\n\n\n\n\nLab 5: Interrupts\n\n\n\n\n\n\n\n\n\n\n\nAug 27, 2024\n\n\nAvery Smith\n\n\n\n\n\n\n\n\n\n\n\n\nLab 6: The Internet of Things and Serial Peripheral Interface\n\n\n\n\n\n\n\n\n\n\n\nAug 27, 2024\n\n\nAvery Smith\n\n\n\n\n\n\n\n\n\n\n\n\nLab 7: The Advanced Encryption Standard\n\n\n\n\n\n\n\n\n\n\n\nAug 27, 2024\n\n\nAvery Smith\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/week1.html",
    "href": "posts/week1.html",
    "title": "Week 1 Reflection",
    "section": "",
    "text": "Week 1 of this course was deceptively difficult. The main purpose of the lab was to make a seven-segment display controller to represent hex 0-F based on the position of 4 onboard dip-switches. This design challenge was straightforward and mostly easy for me to figure out. However, since this was the first lab of the class, I had to download and setup all of the FPGA/MCU programming, interfacing, and simulation software while using GitHub for the first time in ernest. Between licensing issues, duplicate main/master branches, and MCU firmware issues, it’s not an exaggeration to say this was the most difficult first assignment I’ve ever had. That being said (and I had to write about it somehwere), after navigating this lab, I feel like I can take on anything this class has to throw at me. I’m excited to work with System Verilog (a phrase I never thought I would say) to make real-life designs."
  },
  {
    "objectID": "posts/week3.html",
    "href": "posts/week3.html",
    "title": "Week 3 Reflection",
    "section": "",
    "text": "I’m proud of my work this week. I finally found a workflow that works for me, and I took advantage of the available resources to make this project as easy as possible. Lab 3 has a lot of pieces that all need to work together to succeed. The scanner and debouncing modules were quite complicated and required thinking about the internals and how they connect to the rest of the project simultaneously.\nAfter I developed the modules in my head and my project notes, I wrote the SystemVerilog. This step illuminated some lapses in consideration in the conceptual stage, but overall, transferring my intended design to SystemVerilog was straightforward. The main thing I want to talk about in this blog is the testing process.\nI normally avoid testing as much as possible because it feels tedious and arduous. However, I couldn’t have completed this week’s lab without insights only granted by simulating my design. Most of the time I spent on this lab was going back and forth between simulation and my SystemVerilog and it was incredibly helpful. It’s much easier to determine what isn’t working when I can look at all the signals inside of a module. Then, when I uploaded my code to the FPGA, I was almost certain it would work - and it did! I know some issues won’t show up in simulation, so I still respect the physical debugging process, but in the future, I won’t rush to upload my SystemVerilog until I’m sure it works in simulation.\nI also noticed that because I started earlier and spaced out my time better throughout the weekend, I didn’t feel nearly as behind as I did last week. I’m not sure how the workflow will change as we move to work with the MCU, but I hope my reflecting on what went well this week will lend helpful insights that apply to the rest of the course."
  }
]